# Agym

Agym - набор инструментов и платформа-песочница для экспериментов в создании искусственного интеллекта для компьютерных игр; аналогом [openai/gym](https://github.com/openai/gym).

## Описание

![](./static/gifs/gameplay.gif)

## Презентация (для читателей cv)

В силу некоторых причин было принято решение использовать этот проект как часть моего портфолио, поэтому в этой секции вы найдёте более подробное описание тех частей и характеристик приложения, которые я нашёл примечательными и достойными вашего внимания.

### Геометрические примитивы

В контексте решения задачи обнаружения и обработки столкновений был реализован набор низкоуровневых геометрических примитивов таких как:
- Двумерный вектор (она же точка на плоскости <ссылка на код вектора>)
- Прямая на плоскости (<ссылка на код прямой>)
- Отрезок на плоскости (<ссылка на код отрезка>)

Для удобства у некоторых из них были перегружены математические операции сложения, умножения на скаляр, унарный минус, скалярное произведение и прочее.
Это позволяет писать более понятный высокоуровневый код решая математические задачи.
Вот так, на пример, выглядит [код](<ссылка на код нахождения пересечения шаров>) нахождения момента времени и точки столкновения двух шаров, где все переменные кроме `radius` и `t` являются математическими векторами:

```python
    radius = ball1.radius
    s1, f1 = ball1.fake_update(dt)
    s2, f2 = ball2.fake_update(dt)

    v1 = f1 - s1
    v2 = f2 - s2
    a = s1 - s2
    b = v1 - v2

    t = -a.scalar(b)
    t = max(0, min(t, b.norm2()))

    shift = a * b.norm2() + b * t

    if shift.norm2() < ((2 * radius - EPS) * b.norm2()) ** 2:
        point = (f1 + f2) / 2
```

Поверх низкоуровневых примитивов был реализован набор геометрических фигур:
- Окружность (<ссылка на код окружности>)
- Треугольник (<ссылка на код треугольника>)
- Прямоугольник (с параллельными осям сторонами, <ссылка на код прямоугольника>)

На базе геометрических фигур же была реализована полиморфная функция для нахождения точки пересечения этих базовых геометрических фигур друг с другом. [Её][<ссылка на код функции>] сигнатура:

```python
IntersectionStrict = Point
Intersection = Optional[IntersectionStrict]

def get_intersection(a: Shape, b: Shape) -> Intersection:
    ...
```

### Обнаружение и обработка столкновений

Подходы в обработке столкновений подразделяют на несколько типов:

- A prior (априорная) - обнаружение и обработка столкновения "до" фактического столкновения
- A posterior - обнаружение и обработка столкновения уже "после" фактического столкновения

Была выбран первый вариант из-за кажущейся большей простоты поддержания инварианта "непересечения" объектов друг с другом.

#### Непрерывность

Обнаружения столкновений, а также обновление состояния сцены происходит через фиксированные промежутки времени, которые далее будут называться "тиками".
Таким образом в одном тике объекты не пересекаются, а в следующем за ним тике уже может быть пересечение, которые должно быть обработано.
При высокой скорости объектов относительно друг друга и немалым абсолютным временем между тиками, расстояние между ними в первом тике может быть настолько значительным, что правдоподобная обработка такого "столкновения" может оказаться затруднительной.
Кроме этого, может возникнуть эффект, что идентичные сцены при разной частоте обработки (frame rate) перейдут в совершенно разные состояние после некоторой цепочки обработок.

Чтобы избежать эффектов выше был реализован механизм нахождения времени первого столкновения объектов с заранее заданной точностью с последующей обработкой (далее именуемый "шаг") и обработки тика в несколько таких шагов.
Точное время столкновения определяется бинарным поиском, что позволяется значительно увеличить реалистичность и правдоподобность поведения объектов, а из-за малого количества столкновения на самой сцене и некоторого количества других эвристик такой подход почти не сказывается на производительности.

Ниже видео-демонстрация идентичность поведения объектов одной и той же сцены при разном фреймрейте и разном степени замедления видео:
- <гифка сцены при fps 100 и playback 1>
- <гифка сцены при fps 100 и playback 0.1>
- <гифка сцены при fps 20 и playback 0.1>
- <гифка сцены при fps 4 и playback 0.1>


#### Bounding volume hierarchy

TBD

### Абстракция

TBD

### Адаптивность размера игры

TBD

### Шина сообщений

TBD

### Искусственный интеллект

TBD

### Игровые механики

TBD

### Ray marching

TBD

### Sandbox


## Требования

- Python (3.8)
- Poetry
- Make

Узнать больше информации об используемых пакетах вы можете найти [здесь](https://github.com/hatterton/agym/blob/develop/src/pyproject.toml).

## Установка

```bash
git lfs install
git lfs pull
make install
```

## Запуск

```bash
make run
```

